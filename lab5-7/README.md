# **Лабораторная работа №5-7** (Вариант 44)

## Цель работы

**Целью** является приобретение практических навыков в:

- Управлении серверами сообщений _(№5)_
- Применение отложенных вычислений _(№6)_
- Интеграция программных систем друг с другом _(№7)_

## Задание

Реализовать распределенную систему по асинхронной обработке запросов. В данной распределенной системе должно существовать 2 вида узлов: «управляющий» и «вычислительный». Необходимо объединить данные узлы в соответствии с той топологией, которая определена вариантом. Связь между узлами необходимо осуществить при помощи технологии очередей сообщений. Также в данной системе необходимо предусмотреть проверку доступности узлов в соответствии с вариантом. При убийстве («kill -9») любого вычислительного узла система должна пытаться максимально сохранять свою работоспособность, а именно все дочерние узлы убитого узла могут стать недоступными, но родительские узлы должны сохранить свою работоспособность.

Управляющий узел отвечает за ввод команд от пользователя и отправку этих команд на вычислительные узлы. Список основных поддерживаемых команд:

### Создание нового вычислительного узла (1)

Формат команды: `create id [parent]`

- `id` – целочисленный идентификатор нового вычислительного узла

- `parent` – целочисленный идентификатор родительского узла. Если топологией не предусмотрено введение данного параметра, то его необходимо игнорировать (если его ввели)

#### Формат вывода (1)

```bash
«Ok: pid», где pid – идентификатор процесса для созданного вычислительного узла
«Error: Already exists» - вычислительный узел с таким идентификатором уже существует
«Error: Parent not found» - нет такого родительского узла с таким идентификатором
«Error: Parent is unavailable» - родительский узел существует, но по каким-то причинам с ним не удается связаться
«Error: [Custom error]» - любая другая обрабатываемая ошибка
```

#### Пример (1)

```bash
> create 10 5
Ok: 3128
```

> **Примечания:** создание нового управляющего узла осуществляется пользователем программы при помощи запуска исполняемого файла. `Id` и `pid` — это разные идентификаторы.

### Исполнение команды на вычислительном узле (2)

Формат команды: `exec id [params]`

- `id` – целочисленный идентификатор вычислительного узла, на который отправляется команда

#### Формат вывода (2)

```bash
«Ok:id: [result]», где result – результат выполненной команды
«Error:id: Not found» - вычислительный узел с таким идентификатором не найден
«Error:id: Node is unavailable» - по каким-то причинам не удается связаться с вычислительным узлом
«Error:id: [Custom error]» - любая другая обрабатываемая ошибка
```

#### Пример (2)

Можно найти в описании конкретной команды, определенной вариантом задания.

> **Примечание:** выполнение команд должно быть асинхронным. Т.е. пока выполняется команда на одном из вычислительных узлов, то можно отправить следующую команду на другой вычислительный узел.

## Данные по варианту

### Типология №4

Узлы находятся в идеально сбалансированном бинарном дереве. Каждый следующий узел должен добавляться в самое наименьшее поддерево. `[parent]` — является
необязательным параметром.

### Типы команд для вычислительных узлов №1 (подсчет суммы n чисел)

Формат команды: `exec id n k1 … kn`

- `id` – целочисленный идентификатор вычислительного узла, на который отправляется команда
- `n` – количество складываемых чисел (от 1 до 108)
- `k1 … kn` – складываемые числа

**Пример:**

```bash
> exec 10 3 1 2 3
Ok:10: 6
```

### Тип проверки доступности узлов №3

Формат команды: `heartbit time`

Каждый узел начинает сообщать раз в `time` миллисекунд о том, что он работоспособен. Если от узла нет сигнала в течении `4*time` миллисекунд, то должна выводится пользователю строка: `«Heartbit: node id is unavailable now»`, где `id` – идентификатор недоступного вычислительного узла.

**Пример:**

```bash
> heartbit 2000
Ok
```

### Технологии очередей сообщений

ZeroMQ

## Перед началом работы

1. Установите [ZeroMQ _(cppzmq)_](https://zeromq.org/download/)
